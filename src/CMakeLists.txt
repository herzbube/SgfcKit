include( ${CMAKE_CURRENT_SOURCE_DIR}/${SOURCES_LIST_FILE_NAME} )
if ( NOT DEFINED SOURCES )
  message ( FATAL_ERROR "List of source files not defined by ${CMAKE_CURRENT_SOURCE_DIR}/${SOURCES_LIST_FILE_NAME}" )
endif()
if ( NOT DEFINED HEADERS_PRIVATE )
  message ( FATAL_ERROR "List of private header files not defined by ${CMAKE_CURRENT_SOURCE_DIR}/${SOURCES_LIST_FILE_NAME}" )
endif()
if ( NOT DEFINED HEADERS_PUBLIC )
  message ( FATAL_ERROR "List of public header files not defined by ${CMAKE_CURRENT_SOURCE_DIR}/${SOURCES_LIST_FILE_NAME}" )
endif()

# Find the Foundation system framework. The basic objc system library is not
# sufficient because the project requires types such as NSString that are not
# defined in the library.
find_library ( FOUNDATION_SYSTEM_FRAMEWORK Foundation REQUIRED )

# An Xcode project that is generated by CMake doesn't build the shared or static
# library targets that we define further down, if the library targets only
# contains object files from the object library. Whether this is a deficiency in
# Xcode or in CMake's Xcode generator is unknown, but the problem seems to be
# well known, as it is even acknowledged in the CMake docs for object libraries
# [1].
#
#   Some native build systems (such as Xcode) may not like targets that have
#   only object files, so consider adding at least one real source file to
#   any target that references $<TARGET_OBJECTS:objlib>.
#
# Here we follow the suggested workaround and remove one source file from the
# list that will be compiled for the object library, for the only reason that
# we can add it to the shared and static library targets further down. Any
# fill will do, the one we pick here has no special significance.
#
# [1] https://cmake.org/cmake/help/latest/command/add_library.html#object-libraries
set ( SOURCE_FILE_EXCEPTED_FROM_OBJECT_LIBRARY factory/SGFCKitFactory.mm )
list (
  REMOVE_ITEM
  SOURCES
  ${SOURCE_FILE_EXCEPTED_FROM_OBJECT_LIBRARY}
)

# The following two targets are "object library" targets: They compile the
# sources but don't aggregate them into an actual shared or static library yet.
# The purpose of this is to avoid compiling the sources twice, once for the
# shared/static library and once for the shared/static library framework.
if ( ${AT_LEAST_ONE_SHARED_LIBRARY_IS_ENABLED} )
  add_library (
    ${SHARED_OBJECT_LIBRARY_TARGET_NAME}
    OBJECT
    ${SOURCES}
    # We list header files here only because we want CMake to add them to an
    # Xcode or Visual Studio project that it generates.
    ${HEADERS_PUBLIC}
    ${HEADERS_PRIVATE}
  )
endif()
if ( ${AT_LEAST_ONE_STATIC_LIBRARY_IS_ENABLED} )
  add_library (
    ${STATIC_OBJECT_LIBRARY_TARGET_NAME}
    OBJECT
    ${SOURCES}
    # We list header files here only because we want CMake to add them to an
    # Xcode or Visual Studio project that it generates.
    ${HEADERS_PUBLIC}
    ${HEADERS_PRIVATE}
  )
endif()

# Here we finally build the shared and static libraries. We build them
# from the same set of object files.
if ( ${ENABLE_SHARED_LIBRARY} )
  add_library (
    ${SHARED_LIBRARY_TARGET_NAME}
    SHARED
    $<TARGET_OBJECTS:${SHARED_OBJECT_LIBRARY_TARGET_NAME}>
    ${SOURCE_FILE_EXCEPTED_FROM_OBJECT_LIBRARY}
  )
endif()
if ( ${ENABLE_STATIC_LIBRARY} )
  add_library (
    ${STATIC_LIBRARY_TARGET_NAME}
    STATIC
    $<TARGET_OBJECTS:${STATIC_OBJECT_LIBRARY_TARGET_NAME}>
    ${SOURCE_FILE_EXCEPTED_FROM_OBJECT_LIBRARY}
  )
endif()

# For macOS and iOS we also provide a shared library framework and a static
# library framework. They are composed of the exact same stuff as the regular
# libraries.
if ( ${ENABLE_SHARED_FRAMEWORK} )
  add_library (
    ${SHARED_FRAMEWORK_TARGET_NAME}
    SHARED
    $<TARGET_OBJECTS:${SHARED_OBJECT_LIBRARY_TARGET_NAME}>
    ${SOURCE_FILE_EXCEPTED_FROM_OBJECT_LIBRARY}
    # Furtherdown we invoke set_property() to set the targets' PUBLIC_HEADER
    # property. For the shared and static library targets this works fine and
    # causes CMake to copy the header files to their proper destination at
    # installation time. For the framework targets, just setting the PUBLIC_HEADER
    # property alone is not sufficient: We also have to list the public headers
    # here in this add_library() invocation, otherwise CMake does not copy them
    # into the framework bundle at build time. This workaround can be found on
    # the CMake mailing list [1] in a thread dating from 2015.
    # [1] http://cmake.3232098.n2.nabble.com/OS-X-framework-headers-with-capital-letters-td7591087.html
    ${HEADERS_PUBLIC}
  )
endif()
if ( ${ENABLE_STATIC_FRAMEWORK} )
  add_library (
    ${STATIC_FRAMEWORK_TARGET_NAME}
    STATIC
    $<TARGET_OBJECTS:${STATIC_OBJECT_LIBRARY_TARGET_NAME}>
    ${SOURCE_FILE_EXCEPTED_FROM_OBJECT_LIBRARY}
    # For an explanation of this line, see the comment above in the add_library()
    # command for SHARED_FRAMEWORK_TARGET_NAME.
    ${HEADERS_PUBLIC}
  )
endif()

# Here we associate the public header files with the library and framework
# targets. This causes CMake to install them automatically, without us having
# to define a special install rule.
# - For frameworks this is necessary because each framework gets its own copy
#   of the header files.
# - For the libraries we would need only one association because when installed
#   both libraries share the same set of header files. We still associate the
#   files with both library targets, to make sure that the header files will be
#   installed even if the user chooses to build and install only one of the
#   libraries. If the user builds and installs both libraries, then the header
#   files will get installed twice.
#
# Note: It's not possible to make the association with all targets at the same
# time with only one single invocation of set_target_properties(). For unknown
# reasons this does not work, it only copies one single header file to be copied
# instead of the the entire set.
if ( ${ENABLE_SHARED_LIBRARY} )
  set_property (
    TARGET ${SHARED_LIBRARY_TARGET_NAME}
    PROPERTY PUBLIC_HEADER ${HEADERS_PUBLIC}
  )
endif()
if ( ${ENABLE_STATIC_LIBRARY} )
  set_property (
    TARGET ${STATIC_LIBRARY_TARGET_NAME}
    PROPERTY PUBLIC_HEADER ${HEADERS_PUBLIC}
  )
endif()
if ( ${ENABLE_SHARED_FRAMEWORK} )
  set_property (
    TARGET ${SHARED_FRAMEWORK_TARGET_NAME}
    PROPERTY PUBLIC_HEADER ${HEADERS_PUBLIC}
  )
endif()
if ( ${ENABLE_STATIC_FRAMEWORK} )
  set_property (
    TARGET ${STATIC_FRAMEWORK_TARGET_NAME}
    PROPERTY PUBLIC_HEADER ${HEADERS_PUBLIC}
  )
endif()

# Set the targets' output names, which in some cases deviate from the target
# name.
if ( ${ENABLE_SHARED_LIBRARY} )
  set_target_properties (
    ${SHARED_LIBRARY_TARGET_NAME}
    PROPERTIES
    OUTPUT_NAME "${SHARED_LIBRARY_OUTPUT_NAME}"
  )
endif()
if ( ${ENABLE_STATIC_LIBRARY} )
  set_target_properties (
    ${STATIC_LIBRARY_TARGET_NAME}
    PROPERTIES
    OUTPUT_NAME "${STATIC_LIBRARY_OUTPUT_NAME}"
  )
endif()
if ( ${ENABLE_SHARED_FRAMEWORK} )
  set_target_properties (
    ${SHARED_FRAMEWORK_TARGET_NAME}
    PROPERTIES
    OUTPUT_NAME "${SHARED_FRAMEWORK_OUTPUT_NAME}"
  )
endif()
if ( ${ENABLE_STATIC_FRAMEWORK} )
  set_target_properties (
    ${STATIC_FRAMEWORK_TARGET_NAME}
    PROPERTIES
    OUTPUT_NAME "${STATIC_FRAMEWORK_OUTPUT_NAME}"
  )
endif()

# Mark the framework targets as frameworks. Because of this CMake generates
# the framework bundle folder structure on macOS/iOS.
# TODO: Set more properties. Check out this example:
# https://cmake.org/cmake/help/latest/prop_tgt/FRAMEWORK.html
if ( ${ENABLE_SHARED_FRAMEWORK} )
  set_target_properties (
    ${SHARED_FRAMEWORK_TARGET_NAME}
    PROPERTIES
    FRAMEWORK TRUE
  )
endif()
if ( ${ENABLE_STATIC_FRAMEWORK} )
  set_target_properties (
    ${STATIC_FRAMEWORK_TARGET_NAME}
    PROPERTIES
    FRAMEWORK TRUE
  )
endif()

# Define additional folders where to look for include files.
# -  ${FOUNDATION} - The Foundation system framework provides essential
#    Objective-C headers (e.g. NSObject.h).
#if ( ${AT_LEAST_ONE_SHARED_LIBRARY_IS_ENABLED} )
#  target_include_directories (
#    ${SHARED_OBJECT_LIBRARY_TARGET_NAME}
#    PUBLIC
#    ${FOUNDATION}
#  )
#endif()
#if ( ${AT_LEAST_ONE_STATIC_LIBRARY_IS_ENABLED} )
#  target_include_directories (
#    ${STATIC_OBJECT_LIBRARY_TARGET_NAME}
#    PUBLIC
#    ${FOUNDATION}
#  )
#endif()
#if ( ${ENABLE_SHARED_LIBRARY} )
#  target_include_directories (
#    ${SHARED_LIBRARY_TARGET_NAME}
#    PUBLIC
#    ${FOUNDATION}
#  )
#endif()
#if ( ${ENABLE_STATIC_LIBRARY} )
#  target_include_directories (
#    ${STATIC_LIBRARY_TARGET_NAME}
#    PUBLIC
#    ${FOUNDATION}
#  )
#endif()
#if ( ${ENABLE_SHARED_FRAMEWORK} )
#  target_include_directories (
#    ${SHARED_FRAMEWORK_TARGET_NAME}
#    PUBLIC
#    ${FOUNDATION}
#  )
#endif()
#if ( ${ENABLE_STATIC_FRAMEWORK} )
#  target_include_directories (
#    ${STATIC_FRAMEWORK_TARGET_NAME}
#    PUBLIC
#    ${FOUNDATION}
#  )
#endif()

# Define additional compile options.
# - Enable ARC and exception-safe ARC
# - Shared libraries need PIC.
if ( ${AT_LEAST_ONE_SHARED_LIBRARY_IS_ENABLED} )
  target_compile_options (
    ${SHARED_OBJECT_LIBRARY_TARGET_NAME}
    PUBLIC
    ${COMPILE_OPTION_OBJECTIVE_C_ARC}
    ${COMPILE_OPTION_OBJECTIVE_C_ARC_EXCEPTIONS}
  )
  set_property (
    TARGET ${SHARED_OBJECT_LIBRARY_TARGET_NAME}
    PROPERTY POSITION_INDEPENDENT_CODE 1
  )
endif()
if ( ${AT_LEAST_ONE_STATIC_LIBRARY_IS_ENABLED} )
  target_compile_options (
    ${STATIC_OBJECT_LIBRARY_TARGET_NAME}
    PUBLIC
    ${COMPILE_OPTION_OBJECTIVE_C_ARC}
    ${COMPILE_OPTION_OBJECTIVE_C_ARC_EXCEPTIONS}
  )
endif()
if ( ${ENABLE_SHARED_LIBRARY} )
  target_compile_options (
    ${SHARED_LIBRARY_TARGET_NAME}
    PUBLIC
    ${COMPILE_OPTION_OBJECTIVE_C_ARC}
    ${COMPILE_OPTION_OBJECTIVE_C_ARC_EXCEPTIONS}
  )
  set_property (
    TARGET ${SHARED_LIBRARY_TARGET_NAME}
    PROPERTY POSITION_INDEPENDENT_CODE 1
  )
endif()
if ( ${ENABLE_STATIC_LIBRARY} )
  target_compile_options (
    ${STATIC_LIBRARY_TARGET_NAME}
    PUBLIC
    ${COMPILE_OPTION_OBJECTIVE_C_ARC}
    ${COMPILE_OPTION_OBJECTIVE_C_ARC_EXCEPTIONS}
  )
endif()
if ( ${ENABLE_SHARED_FRAMEWORK} )
  target_compile_options (
    ${SHARED_FRAMEWORK_TARGET_NAME}
    PUBLIC
    ${COMPILE_OPTION_OBJECTIVE_C_ARC}
    ${COMPILE_OPTION_OBJECTIVE_C_ARC_EXCEPTIONS}
  )
  set_property (
    TARGET ${SHARED_FRAMEWORK_TARGET_NAME}
    PROPERTY POSITION_INDEPENDENT_CODE 1
  )
endif()
if ( ${ENABLE_STATIC_FRAMEWORK} )
  target_compile_options (
    ${STATIC_FRAMEWORK_TARGET_NAME}
    PUBLIC
    ${COMPILE_OPTION_OBJECTIVE_C_ARC}
    ${COMPILE_OPTION_OBJECTIVE_C_ARC_EXCEPTIONS}
  )
endif()

# Define additional link options.
# - Link against the Objective-C system library. This provides essential
#   Objective-C symbols (e.g. NSObject).
# - Link against libsgfc++. The reason why we run target_link_libraries() for
#   the object libraries and the static libraries, even though those don't need
#   to be linked, is that target_link_libraries() also adds the INTERFACE
#   include directories of the linked libsgfc++ target to the include
#   directories of our own targets.
if ( ${AT_LEAST_ONE_SHARED_LIBRARY_IS_ENABLED} )
  target_link_libraries (
    ${SHARED_OBJECT_LIBRARY_TARGET_NAME}
    ${LIBSGFCPLUSPLUS_SHARED_LIBRARY_TARGET_NAME}
  )
endif()
if ( ${AT_LEAST_ONE_STATIC_LIBRARY_IS_ENABLED} )
  target_link_libraries (
    ${STATIC_OBJECT_LIBRARY_TARGET_NAME}
    ${LIBSGFCPLUSPLUS_STATIC_LIBRARY_TARGET_NAME}
  )
endif()
if ( ${ENABLE_SHARED_LIBRARY} )
  target_link_libraries (
    ${SHARED_LIBRARY_TARGET_NAME}
    ${FOUNDATION_SYSTEM_FRAMEWORK}
    ${LIBSGFCPLUSPLUS_SHARED_LIBRARY_TARGET_NAME}
  )
endif()
if ( ENABLE_STATIC_LIBRARY )
  target_link_libraries (
    ${STATIC_LIBRARY_TARGET_NAME}
    ${LIBSGFCPLUSPLUS_STATIC_LIBRARY_TARGET_NAME}
  )
endif()
if ( ENABLE_SHARED_FRAMEWORK )
  target_link_libraries (
    ${SHARED_FRAMEWORK_TARGET_NAME}
    ${FOUNDATION_SYSTEM_FRAMEWORK}
    ${LIBSGFCPLUSPLUS_SHARED_FRAMEWORK_TARGET_NAME}
  )
endif()
if ( ENABLE_STATIC_FRAMEWORK )
  target_link_libraries (
    ${STATIC_FRAMEWORK_TARGET_NAME}
    ${LIBSGFCPLUSPLUS_STATIC_FRAMEWORK_TARGET_NAME}
  )
endif()

# On some systems CMake automatically populates the LIBRARY and PUBLIC_HEADER
# destinations with values defined by the GNUInstallDirs module (e.g. macOS with
# CMake 3.11 and Xcode, Windows with CMake 3.16 and VisualStudio). On other
# systems CMake does not do it automatically (e.g. Ubuntu 18.04 with CMake 3.12
# and GCC, which corresponds to the Travis build system "bionic"). To satisfy
# all systems we have to populate the destinations manually.
if ( ${ENABLE_SHARED_LIBRARY} )
  install (
    TARGETS
    ${SHARED_LIBRARY_TARGET_NAME}
    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
    PUBLIC_HEADER DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/${LIBRARY_BASENAME}
  )
endif()
if ( ENABLE_STATIC_LIBRARY )
  install (
    TARGETS
    ${STATIC_LIBRARY_TARGET_NAME}
    ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
    PUBLIC_HEADER DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/${LIBRARY_BASENAME}
  )
endif()
if ( ENABLE_SHARED_FRAMEWORK )
  install (
    TARGETS
    ${SHARED_FRAMEWORK_TARGET_NAME}
    FRAMEWORK DESTINATION ${FRAMEWORK_DESTINATION_FOLDER_NAME}
    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
    PUBLIC_HEADER DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}
  )
endif()
if ( ENABLE_STATIC_FRAMEWORK )
  install (
    TARGETS
    ${STATIC_FRAMEWORK_TARGET_NAME}
    FRAMEWORK DESTINATION ${FRAMEWORK_DESTINATION_FOLDER_NAME}
    ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
    PUBLIC_HEADER DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}
  )
endif()
